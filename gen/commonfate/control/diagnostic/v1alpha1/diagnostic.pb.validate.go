// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: commonfate/control/diagnostic/v1alpha1/diagnostic.proto

package diagnosticv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetOAuthTokenMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOAuthTokenMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOAuthTokenMetadataRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOAuthTokenMetadataRequestMultiError, or nil if none found.
func (m *GetOAuthTokenMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOAuthTokenMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetOAuthTokenMetadataRequestMultiError(errors)
	}

	return nil
}

// GetOAuthTokenMetadataRequestMultiError is an error wrapping multiple
// validation errors returned by GetOAuthTokenMetadataRequest.ValidateAll() if
// the designated constraints aren't met.
type GetOAuthTokenMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOAuthTokenMetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOAuthTokenMetadataRequestMultiError) AllErrors() []error { return m }

// GetOAuthTokenMetadataRequestValidationError is the validation error returned
// by GetOAuthTokenMetadataRequest.Validate if the designated constraints
// aren't met.
type GetOAuthTokenMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOAuthTokenMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOAuthTokenMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOAuthTokenMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOAuthTokenMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOAuthTokenMetadataRequestValidationError) ErrorName() string {
	return "GetOAuthTokenMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOAuthTokenMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOAuthTokenMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOAuthTokenMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOAuthTokenMetadataRequestValidationError{}

// Validate checks the field values on GetOAuthTokenMetadataResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOAuthTokenMetadataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOAuthTokenMetadataResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetOAuthTokenMetadataResponseMultiError, or nil if none found.
func (m *GetOAuthTokenMetadataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOAuthTokenMetadataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokens() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOAuthTokenMetadataResponseValidationError{
						field:  fmt.Sprintf("Tokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOAuthTokenMetadataResponseValidationError{
						field:  fmt.Sprintf("Tokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOAuthTokenMetadataResponseValidationError{
					field:  fmt.Sprintf("Tokens[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetOAuthTokenMetadataResponseMultiError(errors)
	}

	return nil
}

// GetOAuthTokenMetadataResponseMultiError is an error wrapping multiple
// validation errors returned by GetOAuthTokenMetadataResponse.ValidateAll()
// if the designated constraints aren't met.
type GetOAuthTokenMetadataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOAuthTokenMetadataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOAuthTokenMetadataResponseMultiError) AllErrors() []error { return m }

// GetOAuthTokenMetadataResponseValidationError is the validation error
// returned by GetOAuthTokenMetadataResponse.Validate if the designated
// constraints aren't met.
type GetOAuthTokenMetadataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOAuthTokenMetadataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOAuthTokenMetadataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOAuthTokenMetadataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOAuthTokenMetadataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOAuthTokenMetadataResponseValidationError) ErrorName() string {
	return "GetOAuthTokenMetadataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOAuthTokenMetadataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOAuthTokenMetadataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOAuthTokenMetadataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOAuthTokenMetadataResponseValidationError{}

// Validate checks the field values on OAuthTokenMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OAuthTokenMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuthTokenMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OAuthTokenMetadataMultiError, or nil if none found.
func (m *OAuthTokenMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuthTokenMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AppName

	if all {
		switch v := interface{}(m.GetExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OAuthTokenMetadataValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OAuthTokenMetadataValidationError{
					field:  "ExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OAuthTokenMetadataValidationError{
				field:  "ExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OAuthTokenMetadataMultiError(errors)
	}

	return nil
}

// OAuthTokenMetadataMultiError is an error wrapping multiple validation errors
// returned by OAuthTokenMetadata.ValidateAll() if the designated constraints
// aren't met.
type OAuthTokenMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuthTokenMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuthTokenMetadataMultiError) AllErrors() []error { return m }

// OAuthTokenMetadataValidationError is the validation error returned by
// OAuthTokenMetadata.Validate if the designated constraints aren't met.
type OAuthTokenMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuthTokenMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuthTokenMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuthTokenMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuthTokenMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuthTokenMetadataValidationError) ErrorName() string {
	return "OAuthTokenMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e OAuthTokenMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuthTokenMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuthTokenMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuthTokenMetadataValidationError{}

// Validate checks the field values on ListBackgroundJobsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBackgroundJobsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBackgroundJobsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBackgroundJobsRequestMultiError, or nil if none found.
func (m *ListBackgroundJobsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBackgroundJobsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Count != nil {
		// no validation rules for Count
	}

	if m.State != nil {
		// no validation rules for State
	}

	if len(errors) > 0 {
		return ListBackgroundJobsRequestMultiError(errors)
	}

	return nil
}

// ListBackgroundJobsRequestMultiError is an error wrapping multiple validation
// errors returned by ListBackgroundJobsRequest.ValidateAll() if the
// designated constraints aren't met.
type ListBackgroundJobsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBackgroundJobsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBackgroundJobsRequestMultiError) AllErrors() []error { return m }

// ListBackgroundJobsRequestValidationError is the validation error returned by
// ListBackgroundJobsRequest.Validate if the designated constraints aren't met.
type ListBackgroundJobsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBackgroundJobsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBackgroundJobsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBackgroundJobsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBackgroundJobsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBackgroundJobsRequestValidationError) ErrorName() string {
	return "ListBackgroundJobsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBackgroundJobsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBackgroundJobsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBackgroundJobsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBackgroundJobsRequestValidationError{}

// Validate checks the field values on ListBackgroundJobsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBackgroundJobsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBackgroundJobsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBackgroundJobsResponseMultiError, or nil if none found.
func (m *ListBackgroundJobsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBackgroundJobsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBackgroundJobsResponseValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBackgroundJobsResponseValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBackgroundJobsResponseValidationError{
					field:  fmt.Sprintf("Jobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListBackgroundJobsResponseMultiError(errors)
	}

	return nil
}

// ListBackgroundJobsResponseMultiError is an error wrapping multiple
// validation errors returned by ListBackgroundJobsResponse.ValidateAll() if
// the designated constraints aren't met.
type ListBackgroundJobsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBackgroundJobsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBackgroundJobsResponseMultiError) AllErrors() []error { return m }

// ListBackgroundJobsResponseValidationError is the validation error returned
// by ListBackgroundJobsResponse.Validate if the designated constraints aren't met.
type ListBackgroundJobsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBackgroundJobsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBackgroundJobsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBackgroundJobsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBackgroundJobsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBackgroundJobsResponseValidationError) ErrorName() string {
	return "ListBackgroundJobsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBackgroundJobsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBackgroundJobsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBackgroundJobsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBackgroundJobsResponseValidationError{}

// Validate checks the field values on ListBackgroundJobKindSummaryRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListBackgroundJobKindSummaryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBackgroundJobKindSummaryRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListBackgroundJobKindSummaryRequestMultiError, or nil if none found.
func (m *ListBackgroundJobKindSummaryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBackgroundJobKindSummaryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBackgroundJobKindSummaryRequestMultiError(errors)
	}

	return nil
}

// ListBackgroundJobKindSummaryRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListBackgroundJobKindSummaryRequest.ValidateAll() if the designated
// constraints aren't met.
type ListBackgroundJobKindSummaryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBackgroundJobKindSummaryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBackgroundJobKindSummaryRequestMultiError) AllErrors() []error { return m }

// ListBackgroundJobKindSummaryRequestValidationError is the validation error
// returned by ListBackgroundJobKindSummaryRequest.Validate if the designated
// constraints aren't met.
type ListBackgroundJobKindSummaryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBackgroundJobKindSummaryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBackgroundJobKindSummaryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBackgroundJobKindSummaryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBackgroundJobKindSummaryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBackgroundJobKindSummaryRequestValidationError) ErrorName() string {
	return "ListBackgroundJobKindSummaryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBackgroundJobKindSummaryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBackgroundJobKindSummaryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBackgroundJobKindSummaryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBackgroundJobKindSummaryRequestValidationError{}

// Validate checks the field values on JobSummary with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobSummary) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobSummary with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JobSummaryMultiError, or
// nil if none found.
func (m *JobSummary) ValidateAll() error {
	return m.validate(true)
}

func (m *JobSummary) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Kind

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JobSummaryValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JobSummaryValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JobSummaryValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetLastRun()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobSummaryValidationError{
					field:  "LastRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobSummaryValidationError{
					field:  "LastRun",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastRun()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobSummaryValidationError{
				field:  "LastRun",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTimeElapsed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobSummaryValidationError{
					field:  "TimeElapsed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobSummaryValidationError{
					field:  "TimeElapsed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeElapsed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobSummaryValidationError{
				field:  "TimeElapsed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JobSummaryMultiError(errors)
	}

	return nil
}

// JobSummaryMultiError is an error wrapping multiple validation errors
// returned by JobSummary.ValidateAll() if the designated constraints aren't met.
type JobSummaryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobSummaryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobSummaryMultiError) AllErrors() []error { return m }

// JobSummaryValidationError is the validation error returned by
// JobSummary.Validate if the designated constraints aren't met.
type JobSummaryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobSummaryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobSummaryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobSummaryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobSummaryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobSummaryValidationError) ErrorName() string { return "JobSummaryValidationError" }

// Error satisfies the builtin error interface
func (e JobSummaryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobSummary.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobSummaryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobSummaryValidationError{}

// Validate checks the field values on RiverError with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RiverError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RiverError with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RiverErrorMultiError, or
// nil if none found.
func (m *RiverError) ValidateAll() error {
	return m.validate(true)
}

func (m *RiverError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOccuredAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RiverErrorValidationError{
					field:  "OccuredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RiverErrorValidationError{
					field:  "OccuredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOccuredAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RiverErrorValidationError{
				field:  "OccuredAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Attempt

	// no validation rules for Error

	// no validation rules for Trace

	if len(errors) > 0 {
		return RiverErrorMultiError(errors)
	}

	return nil
}

// RiverErrorMultiError is an error wrapping multiple validation errors
// returned by RiverError.ValidateAll() if the designated constraints aren't met.
type RiverErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RiverErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RiverErrorMultiError) AllErrors() []error { return m }

// RiverErrorValidationError is the validation error returned by
// RiverError.Validate if the designated constraints aren't met.
type RiverErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RiverErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RiverErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RiverErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RiverErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RiverErrorValidationError) ErrorName() string { return "RiverErrorValidationError" }

// Error satisfies the builtin error interface
func (e RiverErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRiverError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RiverErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RiverErrorValidationError{}

// Validate checks the field values on ListBackgroundJobKindSummaryResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListBackgroundJobKindSummaryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBackgroundJobKindSummaryResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListBackgroundJobKindSummaryResponseMultiError, or nil if none found.
func (m *ListBackgroundJobKindSummaryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBackgroundJobKindSummaryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBackgroundJobKindSummaryResponseValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBackgroundJobKindSummaryResponseValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBackgroundJobKindSummaryResponseValidationError{
					field:  fmt.Sprintf("Jobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListBackgroundJobKindSummaryResponseMultiError(errors)
	}

	return nil
}

// ListBackgroundJobKindSummaryResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListBackgroundJobKindSummaryResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBackgroundJobKindSummaryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBackgroundJobKindSummaryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBackgroundJobKindSummaryResponseMultiError) AllErrors() []error { return m }

// ListBackgroundJobKindSummaryResponseValidationError is the validation error
// returned by ListBackgroundJobKindSummaryResponse.Validate if the designated
// constraints aren't met.
type ListBackgroundJobKindSummaryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBackgroundJobKindSummaryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBackgroundJobKindSummaryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBackgroundJobKindSummaryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBackgroundJobKindSummaryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBackgroundJobKindSummaryResponseValidationError) ErrorName() string {
	return "ListBackgroundJobKindSummaryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBackgroundJobKindSummaryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBackgroundJobKindSummaryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBackgroundJobKindSummaryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBackgroundJobKindSummaryResponseValidationError{}

// Validate checks the field values on Job with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Job) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Job with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobMultiError, or nil if none found.
func (m *Job) ValidateAll() error {
	return m.validate(true)
}

func (m *Job) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Attempt

	if all {
		switch v := interface{}(m.GetAttemptedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "AttemptedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "AttemptedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAttemptedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "AttemptedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EncodedArgs

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JobValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JobValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JobValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFinalizedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "FinalizedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "FinalizedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalizedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "FinalizedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Kind

	// no validation rules for MaxAttempts

	// no validation rules for Metadata

	// no validation rules for Priority

	// no validation rules for Queue

	if all {
		switch v := interface{}(m.GetScheduledAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "ScheduledAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "ScheduledAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetScheduledAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "ScheduledAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	if len(errors) > 0 {
		return JobMultiError(errors)
	}

	return nil
}

// JobMultiError is an error wrapping multiple validation errors returned by
// Job.ValidateAll() if the designated constraints aren't met.
type JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobMultiError) AllErrors() []error { return m }

// JobValidationError is the validation error returned by Job.Validate if the
// designated constraints aren't met.
type JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobValidationError) ErrorName() string { return "JobValidationError" }

// Error satisfies the builtin error interface
func (e JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobValidationError{}

// Validate checks the field values on AttemptError with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AttemptError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AttemptError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AttemptErrorMultiError, or
// nil if none found.
func (m *AttemptError) ValidateAll() error {
	return m.validate(true)
}

func (m *AttemptError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AttemptErrorValidationError{
					field:  "At",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AttemptErrorValidationError{
					field:  "At",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AttemptErrorValidationError{
				field:  "At",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Attempt

	// no validation rules for Error

	// no validation rules for Trace

	if len(errors) > 0 {
		return AttemptErrorMultiError(errors)
	}

	return nil
}

// AttemptErrorMultiError is an error wrapping multiple validation errors
// returned by AttemptError.ValidateAll() if the designated constraints aren't met.
type AttemptErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AttemptErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AttemptErrorMultiError) AllErrors() []error { return m }

// AttemptErrorValidationError is the validation error returned by
// AttemptError.Validate if the designated constraints aren't met.
type AttemptErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AttemptErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AttemptErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AttemptErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AttemptErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AttemptErrorValidationError) ErrorName() string { return "AttemptErrorValidationError" }

// Error satisfies the builtin error interface
func (e AttemptErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAttemptError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AttemptErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AttemptErrorValidationError{}

// Validate checks the field values on AllDiagnostics with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AllDiagnostics) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllDiagnostics with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AllDiagnosticsMultiError,
// or nil if none found.
func (m *AllDiagnostics) ValidateAll() error {
	return m.validate(true)
}

func (m *AllDiagnostics) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOauthTokenMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AllDiagnosticsValidationError{
					field:  "OauthTokenMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AllDiagnosticsValidationError{
					field:  "OauthTokenMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOauthTokenMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AllDiagnosticsValidationError{
				field:  "OauthTokenMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AllDiagnosticsMultiError(errors)
	}

	return nil
}

// AllDiagnosticsMultiError is an error wrapping multiple validation errors
// returned by AllDiagnostics.ValidateAll() if the designated constraints
// aren't met.
type AllDiagnosticsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllDiagnosticsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllDiagnosticsMultiError) AllErrors() []error { return m }

// AllDiagnosticsValidationError is the validation error returned by
// AllDiagnostics.Validate if the designated constraints aren't met.
type AllDiagnosticsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllDiagnosticsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllDiagnosticsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllDiagnosticsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllDiagnosticsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllDiagnosticsValidationError) ErrorName() string { return "AllDiagnosticsValidationError" }

// Error satisfies the builtin error interface
func (e AllDiagnosticsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllDiagnostics.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllDiagnosticsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllDiagnosticsValidationError{}

// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: commonfate/access/v1alpha1/access.proto

package accessv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on QueryApproversRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryApproversRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryApproversRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryApproversRequestMultiError, or nil if none found.
func (m *QueryApproversRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryApproversRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Query.(type) {
	case *QueryApproversRequest_TargetRole:
		if v == nil {
			err := QueryApproversRequestValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTargetRole()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryApproversRequestValidationError{
						field:  "TargetRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryApproversRequestValidationError{
						field:  "TargetRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTargetRole()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryApproversRequestValidationError{
					field:  "TargetRole",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *QueryApproversRequest_Grant:
		if v == nil {
			err := QueryApproversRequestValidationError{
				field:  "Query",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGrant()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryApproversRequestValidationError{
						field:  "Grant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryApproversRequestValidationError{
						field:  "Grant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGrant()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryApproversRequestValidationError{
					field:  "Grant",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return QueryApproversRequestMultiError(errors)
	}

	return nil
}

// QueryApproversRequestMultiError is an error wrapping multiple validation
// errors returned by QueryApproversRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryApproversRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryApproversRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryApproversRequestMultiError) AllErrors() []error { return m }

// QueryApproversRequestValidationError is the validation error returned by
// QueryApproversRequest.Validate if the designated constraints aren't met.
type QueryApproversRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryApproversRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryApproversRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryApproversRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryApproversRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryApproversRequestValidationError) ErrorName() string {
	return "QueryApproversRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryApproversRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryApproversRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryApproversRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryApproversRequestValidationError{}

// Validate checks the field values on TargetRole with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TargetRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TargetRole with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TargetRoleMultiError, or
// nil if none found.
func (m *TargetRole) ValidateAll() error {
	return m.validate(true)
}

func (m *TargetRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TargetRoleValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TargetRoleValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TargetRoleValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TargetRoleValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TargetRoleValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TargetRoleValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TargetRoleMultiError(errors)
	}

	return nil
}

// TargetRoleMultiError is an error wrapping multiple validation errors
// returned by TargetRole.ValidateAll() if the designated constraints aren't met.
type TargetRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TargetRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TargetRoleMultiError) AllErrors() []error { return m }

// TargetRoleValidationError is the validation error returned by
// TargetRole.Validate if the designated constraints aren't met.
type TargetRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TargetRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TargetRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TargetRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TargetRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TargetRoleValidationError) ErrorName() string { return "TargetRoleValidationError" }

// Error satisfies the builtin error interface
func (e TargetRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTargetRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TargetRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TargetRoleValidationError{}

// Validate checks the field values on QueryApproversResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryApproversResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryApproversResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryApproversResponseMultiError, or nil if none found.
func (m *QueryApproversResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryApproversResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetApprovers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryApproversResponseValidationError{
						field:  fmt.Sprintf("Approvers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryApproversResponseValidationError{
						field:  fmt.Sprintf("Approvers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryApproversResponseValidationError{
					field:  fmt.Sprintf("Approvers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryApproversResponseMultiError(errors)
	}

	return nil
}

// QueryApproversResponseMultiError is an error wrapping multiple validation
// errors returned by QueryApproversResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryApproversResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryApproversResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryApproversResponseMultiError) AllErrors() []error { return m }

// QueryApproversResponseValidationError is the validation error returned by
// QueryApproversResponse.Validate if the designated constraints aren't met.
type QueryApproversResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryApproversResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryApproversResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryApproversResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryApproversResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryApproversResponseValidationError) ErrorName() string {
	return "QueryApproversResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryApproversResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryApproversResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryApproversResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryApproversResponseValidationError{}

// Validate checks the field values on QueryAvailabilitiesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryAvailabilitiesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAvailabilitiesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryAvailabilitiesRequestMultiError, or nil if none found.
func (m *QueryAvailabilitiesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAvailabilitiesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageToken

	if len(errors) > 0 {
		return QueryAvailabilitiesRequestMultiError(errors)
	}

	return nil
}

// QueryAvailabilitiesRequestMultiError is an error wrapping multiple
// validation errors returned by QueryAvailabilitiesRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryAvailabilitiesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAvailabilitiesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAvailabilitiesRequestMultiError) AllErrors() []error { return m }

// QueryAvailabilitiesRequestValidationError is the validation error returned
// by QueryAvailabilitiesRequest.Validate if the designated constraints aren't met.
type QueryAvailabilitiesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAvailabilitiesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAvailabilitiesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAvailabilitiesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAvailabilitiesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAvailabilitiesRequestValidationError) ErrorName() string {
	return "QueryAvailabilitiesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAvailabilitiesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAvailabilitiesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAvailabilitiesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAvailabilitiesRequestValidationError{}

// Validate checks the field values on QueryAvailabilitiesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryAvailabilitiesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAvailabilitiesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryAvailabilitiesResponseMultiError, or nil if none found.
func (m *QueryAvailabilitiesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAvailabilitiesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAvailabilities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryAvailabilitiesResponseValidationError{
						field:  fmt.Sprintf("Availabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryAvailabilitiesResponseValidationError{
						field:  fmt.Sprintf("Availabilities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryAvailabilitiesResponseValidationError{
					field:  fmt.Sprintf("Availabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return QueryAvailabilitiesResponseMultiError(errors)
	}

	return nil
}

// QueryAvailabilitiesResponseMultiError is an error wrapping multiple
// validation errors returned by QueryAvailabilitiesResponse.ValidateAll() if
// the designated constraints aren't met.
type QueryAvailabilitiesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAvailabilitiesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAvailabilitiesResponseMultiError) AllErrors() []error { return m }

// QueryAvailabilitiesResponseValidationError is the validation error returned
// by QueryAvailabilitiesResponse.Validate if the designated constraints
// aren't met.
type QueryAvailabilitiesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAvailabilitiesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAvailabilitiesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAvailabilitiesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAvailabilitiesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAvailabilitiesResponseValidationError) ErrorName() string {
	return "QueryAvailabilitiesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAvailabilitiesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAvailabilitiesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAvailabilitiesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAvailabilitiesResponseValidationError{}

// Validate checks the field values on QueryEntitlementsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryEntitlementsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryEntitlementsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryEntitlementsRequestMultiError, or nil if none found.
func (m *QueryEntitlementsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryEntitlementsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageToken

	if m.TargetType != nil {
		// no validation rules for TargetType
	}

	if len(errors) > 0 {
		return QueryEntitlementsRequestMultiError(errors)
	}

	return nil
}

// QueryEntitlementsRequestMultiError is an error wrapping multiple validation
// errors returned by QueryEntitlementsRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryEntitlementsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryEntitlementsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryEntitlementsRequestMultiError) AllErrors() []error { return m }

// QueryEntitlementsRequestValidationError is the validation error returned by
// QueryEntitlementsRequest.Validate if the designated constraints aren't met.
type QueryEntitlementsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryEntitlementsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryEntitlementsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryEntitlementsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryEntitlementsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryEntitlementsRequestValidationError) ErrorName() string {
	return "QueryEntitlementsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryEntitlementsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryEntitlementsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryEntitlementsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryEntitlementsRequestValidationError{}

// Validate checks the field values on QueryEntitlementsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryEntitlementsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryEntitlementsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryEntitlementsResponseMultiError, or nil if none found.
func (m *QueryEntitlementsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryEntitlementsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntitlements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryEntitlementsResponseValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryEntitlementsResponseValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryEntitlementsResponseValidationError{
					field:  fmt.Sprintf("Entitlements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return QueryEntitlementsResponseMultiError(errors)
	}

	return nil
}

// QueryEntitlementsResponseMultiError is an error wrapping multiple validation
// errors returned by QueryEntitlementsResponse.ValidateAll() if the
// designated constraints aren't met.
type QueryEntitlementsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryEntitlementsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryEntitlementsResponseMultiError) AllErrors() []error { return m }

// QueryEntitlementsResponseValidationError is the validation error returned by
// QueryEntitlementsResponse.Validate if the designated constraints aren't met.
type QueryEntitlementsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryEntitlementsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryEntitlementsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryEntitlementsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryEntitlementsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryEntitlementsResponseValidationError) ErrorName() string {
	return "QueryEntitlementsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryEntitlementsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryEntitlementsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryEntitlementsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryEntitlementsResponseValidationError{}

// Validate checks the field values on QueryEntitlementsTreeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryEntitlementsTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryEntitlementsTreeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryEntitlementsTreeRequestMultiError, or nil if none found.
func (m *QueryEntitlementsTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryEntitlementsTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageToken

	if len(errors) > 0 {
		return QueryEntitlementsTreeRequestMultiError(errors)
	}

	return nil
}

// QueryEntitlementsTreeRequestMultiError is an error wrapping multiple
// validation errors returned by QueryEntitlementsTreeRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryEntitlementsTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryEntitlementsTreeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryEntitlementsTreeRequestMultiError) AllErrors() []error { return m }

// QueryEntitlementsTreeRequestValidationError is the validation error returned
// by QueryEntitlementsTreeRequest.Validate if the designated constraints
// aren't met.
type QueryEntitlementsTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryEntitlementsTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryEntitlementsTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryEntitlementsTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryEntitlementsTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryEntitlementsTreeRequestValidationError) ErrorName() string {
	return "QueryEntitlementsTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryEntitlementsTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryEntitlementsTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryEntitlementsTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryEntitlementsTreeRequestValidationError{}

// Validate checks the field values on QueryEntitlementsTreeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryEntitlementsTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryEntitlementsTreeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryEntitlementsTreeResponseMultiError, or nil if none found.
func (m *QueryEntitlementsTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryEntitlementsTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntitlements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryEntitlementsTreeResponseValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryEntitlementsTreeResponseValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryEntitlementsTreeResponseValidationError{
					field:  fmt.Sprintf("Entitlements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return QueryEntitlementsTreeResponseMultiError(errors)
	}

	return nil
}

// QueryEntitlementsTreeResponseMultiError is an error wrapping multiple
// validation errors returned by QueryEntitlementsTreeResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryEntitlementsTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryEntitlementsTreeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryEntitlementsTreeResponseMultiError) AllErrors() []error { return m }

// QueryEntitlementsTreeResponseValidationError is the validation error
// returned by QueryEntitlementsTreeResponse.Validate if the designated
// constraints aren't met.
type QueryEntitlementsTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryEntitlementsTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryEntitlementsTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryEntitlementsTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryEntitlementsTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryEntitlementsTreeResponseValidationError) ErrorName() string {
	return "QueryEntitlementsTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryEntitlementsTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryEntitlementsTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryEntitlementsTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryEntitlementsTreeResponseValidationError{}

// Validate checks the field values on PreviewUserAccessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PreviewUserAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreviewUserAccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PreviewUserAccessRequestMultiError, or nil if none found.
func (m *PreviewUserAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PreviewUserAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrincipal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreviewUserAccessRequestValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreviewUserAccessRequestValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreviewUserAccessRequestValidationError{
				field:  "Principal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.TargetType != nil {
		// no validation rules for TargetType
	}

	if len(errors) > 0 {
		return PreviewUserAccessRequestMultiError(errors)
	}

	return nil
}

// PreviewUserAccessRequestMultiError is an error wrapping multiple validation
// errors returned by PreviewUserAccessRequest.ValidateAll() if the designated
// constraints aren't met.
type PreviewUserAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreviewUserAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreviewUserAccessRequestMultiError) AllErrors() []error { return m }

// PreviewUserAccessRequestValidationError is the validation error returned by
// PreviewUserAccessRequest.Validate if the designated constraints aren't met.
type PreviewUserAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreviewUserAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreviewUserAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreviewUserAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreviewUserAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreviewUserAccessRequestValidationError) ErrorName() string {
	return "PreviewUserAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PreviewUserAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreviewUserAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreviewUserAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreviewUserAccessRequestValidationError{}

// Validate checks the field values on PreviewUserAccessResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PreviewUserAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreviewUserAccessResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PreviewUserAccessResponseMultiError, or nil if none found.
func (m *PreviewUserAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PreviewUserAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntitlements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PreviewUserAccessResponseValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PreviewUserAccessResponseValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PreviewUserAccessResponseValidationError{
					field:  fmt.Sprintf("Entitlements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PreviewUserAccessResponseMultiError(errors)
	}

	return nil
}

// PreviewUserAccessResponseMultiError is an error wrapping multiple validation
// errors returned by PreviewUserAccessResponse.ValidateAll() if the
// designated constraints aren't met.
type PreviewUserAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreviewUserAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreviewUserAccessResponseMultiError) AllErrors() []error { return m }

// PreviewUserAccessResponseValidationError is the validation error returned by
// PreviewUserAccessResponse.Validate if the designated constraints aren't met.
type PreviewUserAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreviewUserAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreviewUserAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreviewUserAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreviewUserAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreviewUserAccessResponseValidationError) ErrorName() string {
	return "PreviewUserAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PreviewUserAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreviewUserAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreviewUserAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreviewUserAccessResponseValidationError{}

// Validate checks the field values on PreviewEntitlementAccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PreviewEntitlementAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreviewEntitlementAccessRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PreviewEntitlementAccessRequestMultiError, or nil if none found.
func (m *PreviewEntitlementAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PreviewEntitlementAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreviewEntitlementAccessRequestValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreviewEntitlementAccessRequestValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreviewEntitlementAccessRequestValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreviewEntitlementAccessRequestValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreviewEntitlementAccessRequestValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreviewEntitlementAccessRequestValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PreviewEntitlementAccessRequestMultiError(errors)
	}

	return nil
}

// PreviewEntitlementAccessRequestMultiError is an error wrapping multiple
// validation errors returned by PreviewEntitlementAccessRequest.ValidateAll()
// if the designated constraints aren't met.
type PreviewEntitlementAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreviewEntitlementAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreviewEntitlementAccessRequestMultiError) AllErrors() []error { return m }

// PreviewEntitlementAccessRequestValidationError is the validation error
// returned by PreviewEntitlementAccessRequest.Validate if the designated
// constraints aren't met.
type PreviewEntitlementAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreviewEntitlementAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreviewEntitlementAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreviewEntitlementAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreviewEntitlementAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreviewEntitlementAccessRequestValidationError) ErrorName() string {
	return "PreviewEntitlementAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PreviewEntitlementAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreviewEntitlementAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreviewEntitlementAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreviewEntitlementAccessRequestValidationError{}

// Validate checks the field values on PreviewEntitlementAccessResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *PreviewEntitlementAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreviewEntitlementAccessResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// PreviewEntitlementAccessResponseMultiError, or nil if none found.
func (m *PreviewEntitlementAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PreviewEntitlementAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccess() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PreviewEntitlementAccessResponseValidationError{
						field:  fmt.Sprintf("Access[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PreviewEntitlementAccessResponseValidationError{
						field:  fmt.Sprintf("Access[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PreviewEntitlementAccessResponseValidationError{
					field:  fmt.Sprintf("Access[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PreviewEntitlementAccessResponseMultiError(errors)
	}

	return nil
}

// PreviewEntitlementAccessResponseMultiError is an error wrapping multiple
// validation errors returned by
// PreviewEntitlementAccessResponse.ValidateAll() if the designated
// constraints aren't met.
type PreviewEntitlementAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreviewEntitlementAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreviewEntitlementAccessResponseMultiError) AllErrors() []error { return m }

// PreviewEntitlementAccessResponseValidationError is the validation error
// returned by PreviewEntitlementAccessResponse.Validate if the designated
// constraints aren't met.
type PreviewEntitlementAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreviewEntitlementAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreviewEntitlementAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreviewEntitlementAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreviewEntitlementAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreviewEntitlementAccessResponseValidationError) ErrorName() string {
	return "PreviewEntitlementAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PreviewEntitlementAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreviewEntitlementAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreviewEntitlementAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreviewEntitlementAccessResponseValidationError{}

// Validate checks the field values on DebugEntitlementAccessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DebugEntitlementAccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugEntitlementAccessRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DebugEntitlementAccessRequestMultiError, or nil if none found.
func (m *DebugEntitlementAccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugEntitlementAccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrincipal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugEntitlementAccessRequestValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugEntitlementAccessRequestValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugEntitlementAccessRequestValidationError{
				field:  "Principal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugEntitlementAccessRequestValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugEntitlementAccessRequestValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugEntitlementAccessRequestValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugEntitlementAccessRequestValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugEntitlementAccessRequestValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugEntitlementAccessRequestValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebugEntitlementAccessRequestMultiError(errors)
	}

	return nil
}

// DebugEntitlementAccessRequestMultiError is an error wrapping multiple
// validation errors returned by DebugEntitlementAccessRequest.ValidateAll()
// if the designated constraints aren't met.
type DebugEntitlementAccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugEntitlementAccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugEntitlementAccessRequestMultiError) AllErrors() []error { return m }

// DebugEntitlementAccessRequestValidationError is the validation error
// returned by DebugEntitlementAccessRequest.Validate if the designated
// constraints aren't met.
type DebugEntitlementAccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugEntitlementAccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugEntitlementAccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugEntitlementAccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugEntitlementAccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugEntitlementAccessRequestValidationError) ErrorName() string {
	return "DebugEntitlementAccessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DebugEntitlementAccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugEntitlementAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugEntitlementAccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugEntitlementAccessRequestValidationError{}

// Validate checks the field values on DebugEntitlementAccessResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DebugEntitlementAccessResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugEntitlementAccessResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DebugEntitlementAccessResponseMultiError, or nil if none found.
func (m *DebugEntitlementAccessResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugEntitlementAccessResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CanRequest

	// no validation rules for AutoApproved

	if all {
		switch v := interface{}(m.GetReason()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugEntitlementAccessResponseValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugEntitlementAccessResponseValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReason()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugEntitlementAccessResponseValidationError{
				field:  "Reason",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPolicySets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DebugEntitlementAccessResponseValidationError{
						field:  fmt.Sprintf("PolicySets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DebugEntitlementAccessResponseValidationError{
						field:  fmt.Sprintf("PolicySets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DebugEntitlementAccessResponseValidationError{
					field:  fmt.Sprintf("PolicySets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEntities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DebugEntitlementAccessResponseValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DebugEntitlementAccessResponseValidationError{
						field:  fmt.Sprintf("Entities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DebugEntitlementAccessResponseValidationError{
					field:  fmt.Sprintf("Entities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DebugEntitlementAccessResponseMultiError(errors)
	}

	return nil
}

// DebugEntitlementAccessResponseMultiError is an error wrapping multiple
// validation errors returned by DebugEntitlementAccessResponse.ValidateAll()
// if the designated constraints aren't met.
type DebugEntitlementAccessResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugEntitlementAccessResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugEntitlementAccessResponseMultiError) AllErrors() []error { return m }

// DebugEntitlementAccessResponseValidationError is the validation error
// returned by DebugEntitlementAccessResponse.Validate if the designated
// constraints aren't met.
type DebugEntitlementAccessResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugEntitlementAccessResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugEntitlementAccessResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugEntitlementAccessResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugEntitlementAccessResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugEntitlementAccessResponseValidationError) ErrorName() string {
	return "DebugEntitlementAccessResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DebugEntitlementAccessResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugEntitlementAccessResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugEntitlementAccessResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugEntitlementAccessResponseValidationError{}

// Validate checks the field values on EntitlementAccessReason with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EntitlementAccessReason) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EntitlementAccessReason with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EntitlementAccessReasonMultiError, or nil if none found.
func (m *EntitlementAccessReason) ValidateAll() error {
	return m.validate(true)
}

func (m *EntitlementAccessReason) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EntitlementAccessReasonMultiError(errors)
	}

	return nil
}

// EntitlementAccessReasonMultiError is an error wrapping multiple validation
// errors returned by EntitlementAccessReason.ValidateAll() if the designated
// constraints aren't met.
type EntitlementAccessReasonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntitlementAccessReasonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntitlementAccessReasonMultiError) AllErrors() []error { return m }

// EntitlementAccessReasonValidationError is the validation error returned by
// EntitlementAccessReason.Validate if the designated constraints aren't met.
type EntitlementAccessReasonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntitlementAccessReasonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntitlementAccessReasonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntitlementAccessReasonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntitlementAccessReasonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntitlementAccessReasonValidationError) ErrorName() string {
	return "EntitlementAccessReasonValidationError"
}

// Error satisfies the builtin error interface
func (e EntitlementAccessReasonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntitlementAccessReason.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntitlementAccessReasonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntitlementAccessReasonValidationError{}

// Validate checks the field values on PrincipalAccess with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PrincipalAccess) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrincipalAccess with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrincipalAccessMultiError, or nil if none found.
func (m *PrincipalAccess) ValidateAll() error {
	return m.validate(true)
}

func (m *PrincipalAccess) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrincipal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrincipalAccessValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrincipalAccessValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrincipalAccessValidationError{
				field:  "Principal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AutoApproved

	if all {
		switch v := interface{}(m.GetReason()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrincipalAccessValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrincipalAccessValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReason()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrincipalAccessValidationError{
				field:  "Reason",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PrincipalAccessMultiError(errors)
	}

	return nil
}

// PrincipalAccessMultiError is an error wrapping multiple validation errors
// returned by PrincipalAccess.ValidateAll() if the designated constraints
// aren't met.
type PrincipalAccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrincipalAccessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrincipalAccessMultiError) AllErrors() []error { return m }

// PrincipalAccessValidationError is the validation error returned by
// PrincipalAccess.Validate if the designated constraints aren't met.
type PrincipalAccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrincipalAccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrincipalAccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrincipalAccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrincipalAccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrincipalAccessValidationError) ErrorName() string { return "PrincipalAccessValidationError" }

// Error satisfies the builtin error interface
func (e PrincipalAccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrincipalAccess.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrincipalAccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrincipalAccessValidationError{}

// Validate checks the field values on Entitlement with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Entitlement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Entitlement with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EntitlementMultiError, or
// nil if none found.
func (m *Entitlement) ValidateAll() error {
	return m.validate(true)
}

func (m *Entitlement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AutoApproved

	for idx, item := range m.GetTargetPath() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntitlementValidationError{
						field:  fmt.Sprintf("TargetPath[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntitlementValidationError{
						field:  fmt.Sprintf("TargetPath[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntitlementValidationError{
					field:  fmt.Sprintf("TargetPath[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReason()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementValidationError{
					field:  "Reason",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReason()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementValidationError{
				field:  "Reason",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RolePriority

	if len(errors) > 0 {
		return EntitlementMultiError(errors)
	}

	return nil
}

// EntitlementMultiError is an error wrapping multiple validation errors
// returned by Entitlement.ValidateAll() if the designated constraints aren't met.
type EntitlementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntitlementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntitlementMultiError) AllErrors() []error { return m }

// EntitlementValidationError is the validation error returned by
// Entitlement.Validate if the designated constraints aren't met.
type EntitlementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntitlementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntitlementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntitlementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntitlementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntitlementValidationError) ErrorName() string { return "EntitlementValidationError" }

// Error satisfies the builtin error interface
func (e EntitlementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntitlement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntitlementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntitlementValidationError{}

// Validate checks the field values on Availability with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Availability) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Availability with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AvailabilityMultiError, or
// nil if none found.
func (m *Availability) ValidateAll() error {
	return m.validate(true)
}

func (m *Availability) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AvailabilityValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AvailabilityValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WorkflowId

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AvailabilityValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetReviewers()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Reviewers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "Reviewers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReviewers()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AvailabilityValidationError{
				field:  "Reviewers",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetSelector()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "TargetSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "TargetSelector",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetSelector()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AvailabilityValidationError{
				field:  "TargetSelector",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDefaultDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "DefaultDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AvailabilityValidationError{
					field:  "DefaultDuration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AvailabilityValidationError{
				field:  "DefaultDuration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AvailabilityMultiError(errors)
	}

	return nil
}

// AvailabilityMultiError is an error wrapping multiple validation errors
// returned by Availability.ValidateAll() if the designated constraints aren't met.
type AvailabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvailabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvailabilityMultiError) AllErrors() []error { return m }

// AvailabilityValidationError is the validation error returned by
// Availability.Validate if the designated constraints aren't met.
type AvailabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvailabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvailabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvailabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvailabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvailabilityValidationError) ErrorName() string { return "AvailabilityValidationError" }

// Error satisfies the builtin error interface
func (e AvailabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvailability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvailabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvailabilityValidationError{}

// Validate checks the field values on Specifier with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Specifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Specifier with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpecifierMultiError, or nil
// if none found.
func (m *Specifier) ValidateAll() error {
	return m.validate(true)
}

func (m *Specifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Specify.(type) {
	case *Specifier_Eid:
		if v == nil {
			err := SpecifierValidationError{
				field:  "Specify",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpecifierValidationError{
						field:  "Eid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpecifierValidationError{
						field:  "Eid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpecifierValidationError{
					field:  "Eid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Specifier_Lookup:
		if v == nil {
			err := SpecifierValidationError{
				field:  "Specify",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Lookup
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SpecifierMultiError(errors)
	}

	return nil
}

// SpecifierMultiError is an error wrapping multiple validation errors returned
// by Specifier.ValidateAll() if the designated constraints aren't met.
type SpecifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpecifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpecifierMultiError) AllErrors() []error { return m }

// SpecifierValidationError is the validation error returned by
// Specifier.Validate if the designated constraints aren't met.
type SpecifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpecifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpecifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpecifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpecifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpecifierValidationError) ErrorName() string { return "SpecifierValidationError" }

// Error satisfies the builtin error interface
func (e SpecifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpecifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpecifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpecifierValidationError{}

// Validate checks the field values on EntitlementInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EntitlementInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EntitlementInput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EntitlementInputMultiError, or nil if none found.
func (m *EntitlementInput) ValidateAll() error {
	return m.validate(true)
}

func (m *EntitlementInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrincipal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementInputValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementInputValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementInputValidationError{
				field:  "Principal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementInputValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementInputValidationError{
					field:  "Target",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementInputValidationError{
				field:  "Target",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementInputValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementInputValidationError{
					field:  "Role",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementInputValidationError{
				field:  "Role",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Duration != nil {

		if all {
			switch v := interface{}(m.GetDuration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntitlementInputValidationError{
						field:  "Duration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntitlementInputValidationError{
						field:  "Duration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntitlementInputValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EntitlementInputMultiError(errors)
	}

	return nil
}

// EntitlementInputMultiError is an error wrapping multiple validation errors
// returned by EntitlementInput.ValidateAll() if the designated constraints
// aren't met.
type EntitlementInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntitlementInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntitlementInputMultiError) AllErrors() []error { return m }

// EntitlementInputValidationError is the validation error returned by
// EntitlementInput.Validate if the designated constraints aren't met.
type EntitlementInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntitlementInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntitlementInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntitlementInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntitlementInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntitlementInputValidationError) ErrorName() string { return "EntitlementInputValidationError" }

// Error satisfies the builtin error interface
func (e EntitlementInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntitlementInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntitlementInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntitlementInputValidationError{}

// Validate checks the field values on BatchEnsureRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchEnsureRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchEnsureRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchEnsureRequestMultiError, or nil if none found.
func (m *BatchEnsureRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchEnsureRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntitlements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchEnsureRequestValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchEnsureRequestValidationError{
						field:  fmt.Sprintf("Entitlements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchEnsureRequestValidationError{
					field:  fmt.Sprintf("Entitlements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetJustification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchEnsureRequestValidationError{
					field:  "Justification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchEnsureRequestValidationError{
					field:  "Justification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJustification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchEnsureRequestValidationError{
				field:  "Justification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	// no validation rules for Breakglass

	if len(errors) > 0 {
		return BatchEnsureRequestMultiError(errors)
	}

	return nil
}

// BatchEnsureRequestMultiError is an error wrapping multiple validation errors
// returned by BatchEnsureRequest.ValidateAll() if the designated constraints
// aren't met.
type BatchEnsureRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchEnsureRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchEnsureRequestMultiError) AllErrors() []error { return m }

// BatchEnsureRequestValidationError is the validation error returned by
// BatchEnsureRequest.Validate if the designated constraints aren't met.
type BatchEnsureRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchEnsureRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchEnsureRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchEnsureRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchEnsureRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchEnsureRequestValidationError) ErrorName() string {
	return "BatchEnsureRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchEnsureRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchEnsureRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchEnsureRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchEnsureRequestValidationError{}

// Validate checks the field values on BatchEnsureResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatchEnsureResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchEnsureResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatchEnsureResponseMultiError, or nil if none found.
func (m *BatchEnsureResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchEnsureResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	for idx, item := range m.GetGrants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchEnsureResponseValidationError{
						field:  fmt.Sprintf("Grants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchEnsureResponseValidationError{
						field:  fmt.Sprintf("Grants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchEnsureResponseValidationError{
					field:  fmt.Sprintf("Grants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetValidation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatchEnsureResponseValidationError{
					field:  "Validation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatchEnsureResponseValidationError{
					field:  "Validation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatchEnsureResponseValidationError{
				field:  "Validation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDiagnostics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatchEnsureResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatchEnsureResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatchEnsureResponseValidationError{
					field:  fmt.Sprintf("Diagnostics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatchEnsureResponseMultiError(errors)
	}

	return nil
}

// BatchEnsureResponseMultiError is an error wrapping multiple validation
// errors returned by BatchEnsureResponse.ValidateAll() if the designated
// constraints aren't met.
type BatchEnsureResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchEnsureResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchEnsureResponseMultiError) AllErrors() []error { return m }

// BatchEnsureResponseValidationError is the validation error returned by
// BatchEnsureResponse.Validate if the designated constraints aren't met.
type BatchEnsureResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchEnsureResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchEnsureResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchEnsureResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchEnsureResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchEnsureResponseValidationError) ErrorName() string {
	return "BatchEnsureResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchEnsureResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchEnsureResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchEnsureResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchEnsureResponseValidationError{}

// Validate checks the field values on GrantState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GrantState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GrantState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GrantStateMultiError, or
// nil if none found.
func (m *GrantState) ValidateAll() error {
	return m.validate(true)
}

func (m *GrantState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGrant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GrantStateValidationError{
					field:  "Grant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GrantStateValidationError{
					field:  "Grant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GrantStateValidationError{
				field:  "Grant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Change

	if len(errors) > 0 {
		return GrantStateMultiError(errors)
	}

	return nil
}

// GrantStateMultiError is an error wrapping multiple validation errors
// returned by GrantState.ValidateAll() if the designated constraints aren't met.
type GrantStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GrantStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GrantStateMultiError) AllErrors() []error { return m }

// GrantStateValidationError is the validation error returned by
// GrantState.Validate if the designated constraints aren't met.
type GrantStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GrantStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GrantStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GrantStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GrantStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GrantStateValidationError) ErrorName() string { return "GrantStateValidationError" }

// Error satisfies the builtin error interface
func (e GrantStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGrantState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GrantStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GrantStateValidationError{}

// Validate checks the field values on Validation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Validation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Validation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ValidationMultiError, or
// nil if none found.
func (m *Validation) ValidateAll() error {
	return m.validate(true)
}

func (m *Validation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HasReason

	if len(errors) > 0 {
		return ValidationMultiError(errors)
	}

	return nil
}

// ValidationMultiError is an error wrapping multiple validation errors
// returned by Validation.ValidateAll() if the designated constraints aren't met.
type ValidationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidationMultiError) AllErrors() []error { return m }

// ValidationValidationError is the validation error returned by
// Validation.Validate if the designated constraints aren't met.
type ValidationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidationValidationError) ErrorName() string { return "ValidationValidationError" }

// Error satisfies the builtin error interface
func (e ValidationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidationValidationError{}

// Validate checks the field values on EntitlementNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EntitlementNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EntitlementNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EntitlementNodeMultiError, or nil if none found.
func (m *EntitlementNode) ValidateAll() error {
	return m.validate(true)
}

func (m *EntitlementNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNamedEid()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementNodeValidationError{
					field:  "NamedEid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementNodeValidationError{
					field:  "NamedEid",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNamedEid()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementNodeValidationError{
				field:  "NamedEid",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Requestable

	// no validation rules for Url

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntitlementNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntitlementNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntitlementNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRoles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntitlementNodeValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntitlementNodeValidationError{
						field:  fmt.Sprintf("Roles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntitlementNodeValidationError{
					field:  fmt.Sprintf("Roles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSuggestedRole()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EntitlementNodeValidationError{
					field:  "SuggestedRole",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EntitlementNodeValidationError{
					field:  "SuggestedRole",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSuggestedRole()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EntitlementNodeValidationError{
				field:  "SuggestedRole",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Parent != nil {

		if all {
			switch v := interface{}(m.GetParent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EntitlementNodeValidationError{
						field:  "Parent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EntitlementNodeValidationError{
						field:  "Parent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EntitlementNodeValidationError{
					field:  "Parent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EntitlementNodeMultiError(errors)
	}

	return nil
}

// EntitlementNodeMultiError is an error wrapping multiple validation errors
// returned by EntitlementNode.ValidateAll() if the designated constraints
// aren't met.
type EntitlementNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntitlementNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntitlementNodeMultiError) AllErrors() []error { return m }

// EntitlementNodeValidationError is the validation error returned by
// EntitlementNode.Validate if the designated constraints aren't met.
type EntitlementNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntitlementNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntitlementNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntitlementNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntitlementNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntitlementNodeValidationError) ErrorName() string { return "EntitlementNodeValidationError" }

// Error satisfies the builtin error interface
func (e EntitlementNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntitlementNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntitlementNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntitlementNodeValidationError{}

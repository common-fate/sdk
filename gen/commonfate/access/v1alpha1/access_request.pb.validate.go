// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: commonfate/access/v1alpha1/access_request.proto

package accessv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	entityv1alpha1 "github.com/common-fate/sdk/gen/commonfate/entity/v1alpha1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = entityv1alpha1.Order(0)
)

// Validate checks the field values on QueryAccessRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryAccessRequestsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAccessRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryAccessRequestsRequestMultiError, or nil if none found.
func (m *QueryAccessRequestsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAccessRequestsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageToken

	// no validation rules for Archived

	for idx, item := range m.GetRequestedBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryAccessRequestsRequestValidationError{
						field:  fmt.Sprintf("RequestedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryAccessRequestsRequestValidationError{
						field:  fmt.Sprintf("RequestedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryAccessRequestsRequestValidationError{
					field:  fmt.Sprintf("RequestedBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetClosedBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryAccessRequestsRequestValidationError{
						field:  fmt.Sprintf("ClosedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryAccessRequestsRequestValidationError{
						field:  fmt.Sprintf("ClosedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryAccessRequestsRequestValidationError{
					field:  fmt.Sprintf("ClosedBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetApprovedBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryAccessRequestsRequestValidationError{
						field:  fmt.Sprintf("ApprovedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryAccessRequestsRequestValidationError{
						field:  fmt.Sprintf("ApprovedBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryAccessRequestsRequestValidationError{
					field:  fmt.Sprintf("ApprovedBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequestStatus

	if m.Order != nil {
		// no validation rules for Order
	}

	if len(errors) > 0 {
		return QueryAccessRequestsRequestMultiError(errors)
	}

	return nil
}

// QueryAccessRequestsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryAccessRequestsRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryAccessRequestsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAccessRequestsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAccessRequestsRequestMultiError) AllErrors() []error { return m }

// QueryAccessRequestsRequestValidationError is the validation error returned
// by QueryAccessRequestsRequest.Validate if the designated constraints aren't met.
type QueryAccessRequestsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAccessRequestsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAccessRequestsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAccessRequestsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAccessRequestsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAccessRequestsRequestValidationError) ErrorName() string {
	return "QueryAccessRequestsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAccessRequestsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAccessRequestsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAccessRequestsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAccessRequestsRequestValidationError{}

// Validate checks the field values on QueryMyAccessRequestsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryMyAccessRequestsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryMyAccessRequestsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryMyAccessRequestsResponseMultiError, or nil if none found.
func (m *QueryMyAccessRequestsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryMyAccessRequestsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccessRequests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryMyAccessRequestsResponseValidationError{
						field:  fmt.Sprintf("AccessRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryMyAccessRequestsResponseValidationError{
						field:  fmt.Sprintf("AccessRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryMyAccessRequestsResponseValidationError{
					field:  fmt.Sprintf("AccessRequests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return QueryMyAccessRequestsResponseMultiError(errors)
	}

	return nil
}

// QueryMyAccessRequestsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryMyAccessRequestsResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryMyAccessRequestsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMyAccessRequestsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMyAccessRequestsResponseMultiError) AllErrors() []error { return m }

// QueryMyAccessRequestsResponseValidationError is the validation error
// returned by QueryMyAccessRequestsResponse.Validate if the designated
// constraints aren't met.
type QueryMyAccessRequestsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryMyAccessRequestsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryMyAccessRequestsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryMyAccessRequestsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryMyAccessRequestsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryMyAccessRequestsResponseValidationError) ErrorName() string {
	return "QueryMyAccessRequestsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryMyAccessRequestsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryMyAccessRequestsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryMyAccessRequestsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryMyAccessRequestsResponseValidationError{}

// Validate checks the field values on QueryMyAccessRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryMyAccessRequestsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryMyAccessRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryMyAccessRequestsRequestMultiError, or nil if none found.
func (m *QueryMyAccessRequestsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryMyAccessRequestsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageToken

	// no validation rules for RequestStatus

	if m.Order != nil {
		// no validation rules for Order
	}

	if len(errors) > 0 {
		return QueryMyAccessRequestsRequestMultiError(errors)
	}

	return nil
}

// QueryMyAccessRequestsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryMyAccessRequestsRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryMyAccessRequestsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryMyAccessRequestsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryMyAccessRequestsRequestMultiError) AllErrors() []error { return m }

// QueryMyAccessRequestsRequestValidationError is the validation error returned
// by QueryMyAccessRequestsRequest.Validate if the designated constraints
// aren't met.
type QueryMyAccessRequestsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryMyAccessRequestsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryMyAccessRequestsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryMyAccessRequestsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryMyAccessRequestsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryMyAccessRequestsRequestValidationError) ErrorName() string {
	return "QueryMyAccessRequestsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryMyAccessRequestsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryMyAccessRequestsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryMyAccessRequestsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryMyAccessRequestsRequestValidationError{}

// Validate checks the field values on QueryAccessRequestsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryAccessRequestsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAccessRequestsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryAccessRequestsResponseMultiError, or nil if none found.
func (m *QueryAccessRequestsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAccessRequestsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccessRequests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryAccessRequestsResponseValidationError{
						field:  fmt.Sprintf("AccessRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryAccessRequestsResponseValidationError{
						field:  fmt.Sprintf("AccessRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryAccessRequestsResponseValidationError{
					field:  fmt.Sprintf("AccessRequests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return QueryAccessRequestsResponseMultiError(errors)
	}

	return nil
}

// QueryAccessRequestsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryAccessRequestsResponse.ValidateAll() if
// the designated constraints aren't met.
type QueryAccessRequestsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAccessRequestsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAccessRequestsResponseMultiError) AllErrors() []error { return m }

// QueryAccessRequestsResponseValidationError is the validation error returned
// by QueryAccessRequestsResponse.Validate if the designated constraints
// aren't met.
type QueryAccessRequestsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAccessRequestsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAccessRequestsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAccessRequestsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAccessRequestsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAccessRequestsResponseValidationError) ErrorName() string {
	return "QueryAccessRequestsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAccessRequestsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAccessRequestsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAccessRequestsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAccessRequestsResponseValidationError{}

// Validate checks the field values on GetAccessRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccessRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccessRequestRequestMultiError, or nil if none found.
func (m *GetAccessRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetAccessRequestRequestMultiError(errors)
	}

	return nil
}

// GetAccessRequestRequestMultiError is an error wrapping multiple validation
// errors returned by GetAccessRequestRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAccessRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessRequestRequestMultiError) AllErrors() []error { return m }

// GetAccessRequestRequestValidationError is the validation error returned by
// GetAccessRequestRequest.Validate if the designated constraints aren't met.
type GetAccessRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessRequestRequestValidationError) ErrorName() string {
	return "GetAccessRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessRequestRequestValidationError{}

// Validate checks the field values on GetAccessRequestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccessRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccessRequestResponseMultiError, or nil if none found.
func (m *GetAccessRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccessRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAccessRequestResponseValidationError{
					field:  "AccessRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAccessRequestResponseValidationError{
					field:  "AccessRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAccessRequestResponseValidationError{
				field:  "AccessRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAccessRequestResponseMultiError(errors)
	}

	return nil
}

// GetAccessRequestResponseMultiError is an error wrapping multiple validation
// errors returned by GetAccessRequestResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAccessRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessRequestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessRequestResponseMultiError) AllErrors() []error { return m }

// GetAccessRequestResponseValidationError is the validation error returned by
// GetAccessRequestResponse.Validate if the designated constraints aren't met.
type GetAccessRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessRequestResponseValidationError) ErrorName() string {
	return "GetAccessRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessRequestResponseValidationError{}

// Validate checks the field values on GetAccessRequestActionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccessRequestActionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessRequestActionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetAccessRequestActionsRequestMultiError, or nil if none found.
func (m *GetAccessRequestActionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessRequestActionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessRequestId

	if len(errors) > 0 {
		return GetAccessRequestActionsRequestMultiError(errors)
	}

	return nil
}

// GetAccessRequestActionsRequestMultiError is an error wrapping multiple
// validation errors returned by GetAccessRequestActionsRequest.ValidateAll()
// if the designated constraints aren't met.
type GetAccessRequestActionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessRequestActionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessRequestActionsRequestMultiError) AllErrors() []error { return m }

// GetAccessRequestActionsRequestValidationError is the validation error
// returned by GetAccessRequestActionsRequest.Validate if the designated
// constraints aren't met.
type GetAccessRequestActionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessRequestActionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessRequestActionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessRequestActionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessRequestActionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessRequestActionsRequestValidationError) ErrorName() string {
	return "GetAccessRequestActionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessRequestActionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessRequestActionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessRequestActionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessRequestActionsRequestValidationError{}

// Validate checks the field values on GetAccessRequestActionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccessRequestActionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccessRequestActionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetAccessRequestActionsResponseMultiError, or nil if none found.
func (m *GetAccessRequestActionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccessRequestActionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAccessRequestActions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAccessRequestActionsResponseValidationError{
					field:  "AccessRequestActions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAccessRequestActionsResponseValidationError{
					field:  "AccessRequestActions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessRequestActions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAccessRequestActionsResponseValidationError{
				field:  "AccessRequestActions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAccessRequestActionsResponseMultiError(errors)
	}

	return nil
}

// GetAccessRequestActionsResponseMultiError is an error wrapping multiple
// validation errors returned by GetAccessRequestActionsResponse.ValidateAll()
// if the designated constraints aren't met.
type GetAccessRequestActionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccessRequestActionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccessRequestActionsResponseMultiError) AllErrors() []error { return m }

// GetAccessRequestActionsResponseValidationError is the validation error
// returned by GetAccessRequestActionsResponse.Validate if the designated
// constraints aren't met.
type GetAccessRequestActionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccessRequestActionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccessRequestActionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccessRequestActionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccessRequestActionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccessRequestActionsResponseValidationError) ErrorName() string {
	return "GetAccessRequestActionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccessRequestActionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccessRequestActionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccessRequestActionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccessRequestActionsResponseValidationError{}

// Validate checks the field values on AccessRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccessRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccessRequestMultiError, or
// nil if none found.
func (m *AccessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AccessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for BatchId

	for idx, item := range m.GetGrants() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AccessRequestValidationError{
						field:  fmt.Sprintf("Grants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AccessRequestValidationError{
						field:  fmt.Sprintf("Grants[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AccessRequestValidationError{
					field:  fmt.Sprintf("Grants[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Reviewable

	// no validation rules for Existing

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccessRequestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccessRequestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccessRequestValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetJustification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccessRequestValidationError{
					field:  "Justification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccessRequestValidationError{
					field:  "Justification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJustification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccessRequestValidationError{
				field:  "Justification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrincipal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccessRequestValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccessRequestValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccessRequestValidationError{
				field:  "Principal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WorkflowId

	// no validation rules for WorkflowName

	if len(errors) > 0 {
		return AccessRequestMultiError(errors)
	}

	return nil
}

// AccessRequestMultiError is an error wrapping multiple validation errors
// returned by AccessRequest.ValidateAll() if the designated constraints
// aren't met.
type AccessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccessRequestMultiError) AllErrors() []error { return m }

// AccessRequestValidationError is the validation error returned by
// AccessRequest.Validate if the designated constraints aren't met.
type AccessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccessRequestValidationError) ErrorName() string { return "AccessRequestValidationError" }

// Error satisfies the builtin error interface
func (e AccessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccessRequestValidationError{}

// Validate checks the field values on AccessRequestActions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccessRequestActions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccessRequestActions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccessRequestActionsMultiError, or nil if none found.
func (m *AccessRequestActions) ValidateAll() error {
	return m.validate(true)
}

func (m *AccessRequestActions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApproveAllowed

	// no validation rules for ActivateAllowed

	// no validation rules for BreakglassActivateAllowed

	// no validation rules for ExtendAllowed

	// no validation rules for ForceCloseAllowed

	if len(errors) > 0 {
		return AccessRequestActionsMultiError(errors)
	}

	return nil
}

// AccessRequestActionsMultiError is an error wrapping multiple validation
// errors returned by AccessRequestActions.ValidateAll() if the designated
// constraints aren't met.
type AccessRequestActionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccessRequestActionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccessRequestActionsMultiError) AllErrors() []error { return m }

// AccessRequestActionsValidationError is the validation error returned by
// AccessRequestActions.Validate if the designated constraints aren't met.
type AccessRequestActionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccessRequestActionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccessRequestActionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccessRequestActionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccessRequestActionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccessRequestActionsValidationError) ErrorName() string {
	return "AccessRequestActionsValidationError"
}

// Error satisfies the builtin error interface
func (e AccessRequestActionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccessRequestActions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccessRequestActionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccessRequestActionsValidationError{}

// Validate checks the field values on ApproveAccessRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveAccessRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveAccessRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveAccessRequestRequestMultiError, or nil if none found.
func (m *ApproveAccessRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveAccessRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ApproveAccessRequestRequestMultiError(errors)
	}

	return nil
}

// ApproveAccessRequestRequestMultiError is an error wrapping multiple
// validation errors returned by ApproveAccessRequestRequest.ValidateAll() if
// the designated constraints aren't met.
type ApproveAccessRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveAccessRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveAccessRequestRequestMultiError) AllErrors() []error { return m }

// ApproveAccessRequestRequestValidationError is the validation error returned
// by ApproveAccessRequestRequest.Validate if the designated constraints
// aren't met.
type ApproveAccessRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveAccessRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveAccessRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveAccessRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveAccessRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveAccessRequestRequestValidationError) ErrorName() string {
	return "ApproveAccessRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveAccessRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveAccessRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveAccessRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveAccessRequestRequestValidationError{}

// Validate checks the field values on ApproveAccessRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveAccessRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveAccessRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveAccessRequestResponseMultiError, or nil if none found.
func (m *ApproveAccessRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveAccessRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDiagnostics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApproveAccessRequestResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApproveAccessRequestResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApproveAccessRequestResponseValidationError{
					field:  fmt.Sprintf("Diagnostics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApproveAccessRequestResponseMultiError(errors)
	}

	return nil
}

// ApproveAccessRequestResponseMultiError is an error wrapping multiple
// validation errors returned by ApproveAccessRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type ApproveAccessRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveAccessRequestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveAccessRequestResponseMultiError) AllErrors() []error { return m }

// ApproveAccessRequestResponseValidationError is the validation error returned
// by ApproveAccessRequestResponse.Validate if the designated constraints
// aren't met.
type ApproveAccessRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveAccessRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveAccessRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveAccessRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveAccessRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveAccessRequestResponseValidationError) ErrorName() string {
	return "ApproveAccessRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveAccessRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveAccessRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveAccessRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveAccessRequestResponseValidationError{}

// Validate checks the field values on CloseAccessRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CloseAccessRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloseAccessRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloseAccessRequestRequestMultiError, or nil if none found.
func (m *CloseAccessRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CloseAccessRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ForceClose

	if len(errors) > 0 {
		return CloseAccessRequestRequestMultiError(errors)
	}

	return nil
}

// CloseAccessRequestRequestMultiError is an error wrapping multiple validation
// errors returned by CloseAccessRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type CloseAccessRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloseAccessRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloseAccessRequestRequestMultiError) AllErrors() []error { return m }

// CloseAccessRequestRequestValidationError is the validation error returned by
// CloseAccessRequestRequest.Validate if the designated constraints aren't met.
type CloseAccessRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloseAccessRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloseAccessRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloseAccessRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloseAccessRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloseAccessRequestRequestValidationError) ErrorName() string {
	return "CloseAccessRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CloseAccessRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloseAccessRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloseAccessRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloseAccessRequestRequestValidationError{}

// Validate checks the field values on CloseAccessRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CloseAccessRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloseAccessRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloseAccessRequestResponseMultiError, or nil if none found.
func (m *CloseAccessRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CloseAccessRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDiagnostics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CloseAccessRequestResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CloseAccessRequestResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CloseAccessRequestResponseValidationError{
					field:  fmt.Sprintf("Diagnostics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CloseAccessRequestResponseMultiError(errors)
	}

	return nil
}

// CloseAccessRequestResponseMultiError is an error wrapping multiple
// validation errors returned by CloseAccessRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type CloseAccessRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloseAccessRequestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloseAccessRequestResponseMultiError) AllErrors() []error { return m }

// CloseAccessRequestResponseValidationError is the validation error returned
// by CloseAccessRequestResponse.Validate if the designated constraints aren't met.
type CloseAccessRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloseAccessRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloseAccessRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloseAccessRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloseAccessRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloseAccessRequestResponseValidationError) ErrorName() string {
	return "CloseAccessRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CloseAccessRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloseAccessRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloseAccessRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloseAccessRequestResponseValidationError{}

// Validate checks the field values on ActivateAccessRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateAccessRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateAccessRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivateAccessRequestRequestMultiError, or nil if none found.
func (m *ActivateAccessRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateAccessRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Breakglass

	if len(errors) > 0 {
		return ActivateAccessRequestRequestMultiError(errors)
	}

	return nil
}

// ActivateAccessRequestRequestMultiError is an error wrapping multiple
// validation errors returned by ActivateAccessRequestRequest.ValidateAll() if
// the designated constraints aren't met.
type ActivateAccessRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateAccessRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateAccessRequestRequestMultiError) AllErrors() []error { return m }

// ActivateAccessRequestRequestValidationError is the validation error returned
// by ActivateAccessRequestRequest.Validate if the designated constraints
// aren't met.
type ActivateAccessRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateAccessRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateAccessRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateAccessRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateAccessRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateAccessRequestRequestValidationError) ErrorName() string {
	return "ActivateAccessRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateAccessRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateAccessRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateAccessRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateAccessRequestRequestValidationError{}

// Validate checks the field values on ActivateAccessRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateAccessRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateAccessRequestResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ActivateAccessRequestResponseMultiError, or nil if none found.
func (m *ActivateAccessRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateAccessRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDiagnostics() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActivateAccessRequestResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActivateAccessRequestResponseValidationError{
						field:  fmt.Sprintf("Diagnostics[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActivateAccessRequestResponseValidationError{
					field:  fmt.Sprintf("Diagnostics[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActivateAccessRequestResponseMultiError(errors)
	}

	return nil
}

// ActivateAccessRequestResponseMultiError is an error wrapping multiple
// validation errors returned by ActivateAccessRequestResponse.ValidateAll()
// if the designated constraints aren't met.
type ActivateAccessRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateAccessRequestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateAccessRequestResponseMultiError) AllErrors() []error { return m }

// ActivateAccessRequestResponseValidationError is the validation error
// returned by ActivateAccessRequestResponse.Validate if the designated
// constraints aren't met.
type ActivateAccessRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateAccessRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateAccessRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateAccessRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateAccessRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateAccessRequestResponseValidationError) ErrorName() string {
	return "ActivateAccessRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateAccessRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateAccessRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateAccessRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateAccessRequestResponseValidationError{}

// Validate checks the field values on Justification with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Justification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Justification with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JustificationMultiError, or
// nil if none found.
func (m *Justification) ValidateAll() error {
	return m.validate(true)
}

func (m *Justification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Reason != nil {
		// no validation rules for Reason
	}

	if len(errors) > 0 {
		return JustificationMultiError(errors)
	}

	return nil
}

// JustificationMultiError is an error wrapping multiple validation errors
// returned by Justification.ValidateAll() if the designated constraints
// aren't met.
type JustificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JustificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JustificationMultiError) AllErrors() []error { return m }

// JustificationValidationError is the validation error returned by
// Justification.Validate if the designated constraints aren't met.
type JustificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JustificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JustificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JustificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JustificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JustificationValidationError) ErrorName() string { return "JustificationValidationError" }

// Error satisfies the builtin error interface
func (e JustificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJustification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JustificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JustificationValidationError{}

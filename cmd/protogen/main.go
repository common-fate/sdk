//go:build ignore
// +build ignore

/*
This file contains code generation code to create a list of all the protofiles that get generated by protobuf from our proto files
This can be used to aid in programatic operations over the API spec
*/

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// Template for the generated Go file
const tmpl = `// Code generated by go generate; DO NOT EDIT.
// This file contains the list of public variables with the specified prefix.

package protofiles

import (
	"google.golang.org/protobuf/reflect/protoreflect"
{{- range $alias, $path := .Imports }}
	{{$alias}} "{{$path}}"
{{- end }}
)

var ProtoFiles = []protoreflect.FileDescriptor{
{{- range $alias, $vars := .Vars }}
{{- range $vars }}
	{{$alias}}.{{.}},
{{- end }}
{{- end }}
}
`

// Data structure to hold the generated output
type templateData struct {
	Imports map[string]string   // Aliases to import paths
	Vars    map[string][]string // Aliases to variables
}

// findPublicVariablesWithPrefix walks through all Go files in a directory and finds public variables with a specific prefix.
func findPublicVariablesWithPrefix(dir, prefix string) (templateData, error) {
	data := templateData{
		Imports: make(map[string]string),
		Vars:    make(map[string][]string),
	}

	err := filepath.Walk(dir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if strings.HasSuffix(info.Name(), ".go") {
			err := findVariablesInFile(path, prefix, &data)
			if err != nil {
				return err
			}
		}
		return nil
	})

	return data, err
}

// generateAlias creates an alias based on the import path and file structure.
func generateAlias(importPath string) string {
	// Split the import path into parts
	parts := strings.Split(importPath, "/")

	// Remove the base URL (e.g., "github.com") and take the remaining path
	if len(parts) > 2 {
		parts = parts[2:]
	}

	// Concatenate the remaining parts to create an alias
	alias := strings.Join(parts, "")
	return alias
}

// findVariablesInFile parses the Go source file and updates the map of variables with their imports.
func findVariablesInFile(filename, prefix string, data *templateData) error {
	fset := token.NewFileSet()

	// Parse the file containing the Go source code
	node, err := parser.ParseFile(fset, filename, nil, parser.AllErrors)
	if err != nil {
		return err
	}

	// Iterate over declarations to find public variables with the prefix
	for _, decl := range node.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			if decl.Tok == token.VAR {
				for _, spec := range decl.Specs {
					varSpec, ok := spec.(*ast.ValueSpec)
					if !ok {
						continue
					}
					for _, name := range varSpec.Names {
						if strings.HasPrefix(name.Name, prefix) && name.IsExported() {

							alias := strings.ReplaceAll(filename, ".", "_")
							alias = strings.ReplaceAll(alias, "/", "_")
							data.Vars[alias] = append(data.Vars[alias], name.Name)
							if _, exists := data.Imports[alias]; !exists {
								data.Imports[alias] = trimAfterLastSlash("github.com/common-fate/sdk/" + filename)
							}
						}
					}
				}
			}
		}
	}

	return nil
}
func trimAfterLastSlash(s string) string {
	pos := strings.LastIndex(s, "/")
	if pos == -1 {
		// No slash found, return the original string
		return s
	}
	// Return the substring up to the last slash
	return s[:pos]
}

// generateOutputFile creates the output Go file using the template.
func generateOutputFile(data templateData) error {

	out := "gen/protofiles/protofiles.go"
	err := ensureDir(out)

	file, err := os.Create(out)
	if err != nil {
		return err
	}
	defer file.Close()

	// Parse and execute the template
	t := template.Must(template.New("output").Parse(tmpl))
	return t.Execute(file, data)
}

func main() {
	// Directory containing the Go package files
	dir := "./gen"
	prefix := "File_commonfate"

	data, err := findPublicVariablesWithPrefix(dir, prefix)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	err = generateOutputFile(data)
	if err != nil {
		fmt.Println("Error generating output file:", err)
	}
}

// ensureDir creates the parent directories if they don't exist
func ensureDir(filePath string) error {
	// Get the directory from the file path
	dir := filepath.Dir(filePath)

	// Create all necessary directories if they do not exist
	return os.MkdirAll(dir, os.ModePerm)
}

syntax = "proto3";

package commonfate.access.v1alpha1;

import "commonfate/control/attest/v1alpha1/attestation.proto";
import "commonfate/access/v1alpha1/access_request.proto";
import "commonfate/access/v1alpha1/grant.proto";
import "commonfate/entity/v1alpha1/entity.proto";
import "commonfate/entity/v1alpha1/uid.proto";
import "commonfate/access/v1alpha1/named_uid.proto";
import "commonfate/access/v1alpha1/user.proto";
import "commonfate/access/v1alpha1/reviewer_preview.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

// AccessService is the Access Handler's user-facing API.
// Users call this API to ensure that they have access to entitlements.
service AccessService {
  // Ensure is a high-level declarative API which can be called to ensure access has been provisioned to an entitlement.
  //
  // The method checks whether the entitlement has been provisioned to the user.
  // If the entitlement has not been provisioned, an Access Request will be created for the entitlement.
  // If a pending Access Request exists for the entitlement, this request is returned.
  //
  // In future, this method may trigger an extension to any Access Requests which are due to expire.
  // 
  //
  // This method is used by the Common Fate CLI in commands like 'cf exec gcp -- <command>' to ensure access
  // is provisioned prior to running a command.
  rpc Ensure(EnsureRequest) returns (EnsureResponse) {}

  // BatchEnsure is a high-level declarative API which can be called to ensure access has been provisioned to multiple entitlements.
  //
  // The method checks whether the entitlement has been provisioned to the user.
  // If the entitlement has not been provisioned, an Access Request will be created for the entitlement.
  // If a pending Access Request exists for the entitlement, this request is returned.
  //
  // In future, this method may trigger an extension to any Access Requests which are due to expire.
  rpc BatchEnsure(BatchEnsureRequest) returns (BatchEnsureResponse) {}

  // Query for JIT availabilities.
  rpc QueryAvailabilities(QueryAvailabilitiesRequest) returns (QueryAvailabilitiesResponse) {}
}

message QueryAvailabilitiesRequest {
   // The token for the next page.
   string page_token = 10;
}

message QueryAvailabilitiesResponse {
  repeated Availability availabilities = 1;
  string next_page_token = 2;
}


message Availability {
  // ID is just used internally and isn't really shown to users except for debugging purposes.
  // users refer to entitlements by the target and role, rather than the internal ID.
  string id = 1;

  // The particular resource which this entitlement gives access to
  NamedUID target = 2;

  // The particular role this entitlement gives access to
  NamedUID role = 3;

  // the JIT workflow associated with the entitlement.
  string workflow_id = 4;

  // The permitted access duration.
  google.protobuf.Duration duration = 5;

  uint32 priority = 6;

  ReviewerPreview reviewers = 7;
}


message EnsureRequest {
  // The entitlements to request access to.
  EntitlementInput entitlement = 1;

  // Optional justification as to why access is required.
  Justification justification = 4;
}

message Specifier {
  oneof specify {
    // Specify a resource using a UID. If you're using Common Fate programatically
    // and you know the resource you want to specify, you should use this field.
    commonfate.entity.v1alpha1.UID uid = 1;

    // Specify a resource using a string lookup. This is used in our CLI
    // to allow end users to look up resources by name, ID and/or UID.
    //
    // The order of matching is:
    // 1. the 'lookup' field will be parsed as a UID - if it's valid it will be a UID lookup
    // 2. the 'lookup' field will be matched against all resource IDs
    // 3. the 'lookup' field will be matched against all resource names.
    //
    // If the lookup is a valid UID but it is not found, the API will return a Not Found error.
    // The API will return an Invalid Arguments error if the lookup is ambiguous and could match
    // multiple resources.
    string lookup = 2;
  }
}

message EntitlementInput {
  // The principal to grant access to.
  // If empty, the current caller will be used as the principal.
  Specifier principal = 1;

   // The resource to grant the principal access to.
  Specifier target = 2;

   // The role to grant the principal access to the resource with.
  Specifier role = 3;
}

message BatchEnsureRequest {
  // The entitlements to request access to.
  repeated EntitlementInput entitlements = 1;

  // Optional justification as to why access is required.
  Justification justification = 2;
}

message EnsureResponse {
  // An ID which can be used to debug the evaluation of the access policies
  // associated with the request.
  string trace_id = 1;

  // An Access Request. Will be nil if access is already active because the user was assigned
  // persistent access to the entitlement.
  AccessRequest access_request = 4;

  // The Grant associated with the Access Request.
  // Unlike the BatchGrant endpoint, the Grant endpoint will always return Access Requests
  // that have a single associated grant. For convenience, the Grant is also returned here.
  Grant grant = 5;

  // User-facing diagnostic warnings
  repeated Diagnostic diagnostics = 6;
}

message BatchEnsureResponse {
  // An ID which can be used to debug the evaluation of the access policies
  // associated with the request.
  string trace_id = 1;

  // An Access Request. Will be nil if access is already active because the user was assigned
  // persistent access to the entitlement.
  repeated AccessRequest access_requests = 4;

  // User-facing diagnostic warnings, for messages such as the user not having permissions
  // to request some of the entitlements they asked for.
  //
  // Rather than failing the entire operation the Access Handler returns warnings.
  repeated Diagnostic diagnostics = 5;
}

message Justification {
  optional string reason = 1;
  optional commonfate.control.attest.v1alpha1.Attestation device_attestation = 2;
}
